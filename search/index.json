[{"content":"n2n 参考:\nhttps://bugxia.com/2396.html\nhttps://www.jianshu.com/p/559c1e582724\n服务器安装  centos  # RPM安装 yum install libzstd -y wget https://github.com/ntop/n2n/releases/download/3.0/n2n-3.0.0-1038.x86_64.rpm rpm -i n2n-3.0.0-1038.x86_64.rpm 启动服务器 启动服务端 #实际使用时，可以去掉 -f 参数，使其后台运行 supernode -p 端口 -f  EasyN2N 服务端（Supernode）附加参数 -p 端口 | Supernode监听端口，默认 7654 -F federation名称 | supernode federation名称，默认为 *Federation -l 主机:端口 | 和 -F 配合，已知的一台Supernode地址和端口 -M | 关闭非用户名密码认证的群组的MAC和IP地址欺骗保护功能 -V 文本 | 自定义字符串（最长19位），用于在管理输出日志中展示 -c 组名称配置文件路径 | 该配置文件中包含允许使用的组名称 -a IP段 | 用于自动分配IP，格式如 -a 192.168.0.0-192.168.255.0/24 -t 端口 | 用于管理supernode --management_password 文本 | 管理端的密码 -v | 输出更多日志   设置开机启动\n# 修改配置文件 sudo vim/etc/n2n/edge.conf ====== -c=组织名 -a=内网地址 -l=节点公网地址:端口 ====== # 设置自启服务 sudo systemctl enable edge sudo systemctl start edge sudo systemctl status edge journalctl -f -u edge # journalctl 查看日志 # -f 实时最新 # -u 指定服务 服务器端口放行  腾讯云的防火墙 若服务器开启了如iptables\\firewalld\\ufw等防火墙，需要放行supernode所设置的端口，否则客户端无法连接  #firewalld  firewall-cmd --zone=public --add-port=9527/udp --permanent firewall-cmd --reload #iptables iptables -I INPUT -p udp --dport 9527 -j ACCEPT service iptables save service iptables restart #ufw ufw allow 9527/udp centos7 默认是firewall\n# 查看状态 systemctl status firewalld # 或者 firewall-cmd --state #　查看所有开放端口 firewall-cmd --zone=public --list-ports # 禁用端口 firewall-cmd --zone=public --remove-port=5672/tcp --permanent #关闭5672端口 客户端组建N2N虚拟局域网 sudo edge -a 局域网ip -c n2n组名 -l [公网ip]:公网端口 -f 参数说明\n-a \u0026lt;mode:address\u0026gt; | n2n网卡的ip地址，即本机的n2n的ip。直接填写IP或者使用 DHCP \u0026#39;-r -a dhcp:0.0.0.0\u0026#39; -c \u0026lt;community\u0026gt; | n2n组，只有相同组的edge之间才能进行通讯 -k \u0026lt;encrypt key\u0026gt; | edge的加密密码 -s \u0026lt;netmask\u0026gt; | 子网掩码 可选 (255.255.255.0). -l \u0026lt;supernode host:port\u0026gt; | supernode的ip和端口 -i \u0026lt;reg_interval\u0026gt; | 注册时间间隔，用于NAT打洞(默认为20秒) -L \u0026lt;reg_ttl\u0026gt; | 当通过超级节点UDP NAT打洞时，注册数据包的TTL(默认0不设置) -p \u0026lt;local port\u0026gt; | 固定本地UDP端口 -u \u0026lt;UID\u0026gt; | 如果不想用root来运行edge，则可指定本机账号的uid，windows下可忽略 -g \u0026lt;GID\u0026gt; | 如果不想用root来运行edge，则可指定本机账号的groupid，windows下可忽略 -f | 带-f时前台运行，不添加-f 参数时作为守护进程运行 -m \u0026lt;MAC address\u0026gt; | n2n虚拟网卡的MAC地址，默认随机设置 | eg. -m 01:02:03:04:05:06 -M \u0026lt;mtu\u0026gt; | MTU 值，默认1290 -r | 启用数据转发功能，当需要访问该设备的局域网时需要设置 -A1 | 禁用载荷加密。不能与key 同时使用(默认为Twofish)。 -A2 ... -A5 or -A | 选择有效载荷加密的密码，需要一个密钥:-A2 = Twofish(默认)， | -A3 or -A (deprecated) = AES-CBC, -A5 = Speck-CTR. -H | Enable full header encryption. Requires supernode with fixed community. -z1 ... -z2 or -z | Enable compression for outgoing data packets: -z1 or -z = lzo1x (default=disabled). -E | 接受多播MAC地址(默认=drop) -S | 不要连接P2P ，总是使用超级节点转发数据 -n \u0026lt;cidr:gateway\u0026gt; | 通过gw路由IPv4网络。使用0.0.0.0/0作为默认gw。可多次设置。 -v | 详细日志 -t \u0026lt;port\u0026gt; | 管理UDP端口(用于机器上的多个edges)。 环境变量: N2N_KEY | 加密密钥(ASCII) 安装tuntap brew tap happynclient/taps brew install tuntap --cask .查看系统信息，您会看到一个名为 tap0的虚拟网卡 sudo ifconfig\nmacos 设置开机启动项 # 在 /Library/LaunchDaemons 新增文件 lomotho.n2n-edge.plist，用于 launchd 控制的开机自启（类似 systemd） \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;KeepAlive\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;RunAtLoad\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;Label\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;lomotho.n2n.edge\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;ProgramArguments\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;/usr/local/bin/edge\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;/usr/local/etc/n2n/edge.conf\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; # 客户端配置文件 # /usr/local/etc/n2n/edge.conf # # The configuration file is similar to the command line, with one option per line. An equal # sign \u0026#39;=\u0026#39; should be used between key and value. Example: -c=mynetwork or --community=mynetwork # This file contains a basic configuration example, please refer to the help (-h) for the full # list of available options. # # -d|--tun-device # Specifies the name of the TUN interface.  # #\t-d=n2n0 # # -c|--community # Specifies the n2n community name the edge belongs to. # -c=xxx # # -k # Sets the encryption key (ASCII). The environment variable N2N_KEY=\u0026lt;key\u0026gt; can also be used.  # #\t-k=mypassword # # -m # Specified the MAC address for the TAP interface (random otherwise). # # -m=DE:AD:BE:EF:99:99 # # -a # Sets the interface address. For DHCP use \u0026#39;-r -a dhcp:0.0.0.0\u0026#39;. # -a=x.x.x.x # # -p # Sets the local UDP port to a fixed port. # # -p=50001 # # -l|--supernode-list # Specifies the supernode IP and port. # -l=x.x.x.x:x # ","date":"2022-12-18T17:02:27+08:00","permalink":"/p/note/","title":"n2n部署"},{"content":"Git Git 常用命令 仓库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] # 下载指定分支 $ git clone -b [branchName] [url] 配置 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name \u0026#34;[name]\u0026#34; $ git config [--global] user.email \u0026#34;[email address]\u0026#34; 增加/删除文件 # 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 代码提交 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend # 或者 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] $ git checkout -b dev origin/dev # 新建分支dev并切换到该分支, 链接到远程dev分支 #　让分支指向另一个提交 git branch main HEAD~3 # 让main分支指向head的前第3个提交 # 或者 git branch -f main HEAD~3 # -f表示强制 # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 或者 $ git branch -u origin/master local-branch # 简写 # 这样 local-branch 就会跟踪 origin/master 了。如果当前就在 local-branch 分支上, 还可以省略 local-branch $ git branch -u origin/master # 合并指定分支到当前分支 $ git merge [branch] # (不推荐) $ git merge --no-ff 要合并的分支 (推荐, 不使用快速合并, 提交历史更加清晰, 不容易出错) # git 分支合并到主分支时，去掉分支的冗余提交。即，将分支的多次提交一次性合并到主分支上。 $ git checkout master # 切换到主分支 $ git merge --squash dev # 一次性合并分支的多次提交 $ git commit -m \u0026#39;xxx版\u0026#39; # 将刚‘合并的提交’提交到主分支master # 选择一个commit，拷贝分支合并进当前分支, 比如把dev的c2和c4拷贝为c2\u0026#39;, c4\u0026#39;, 加到到main分支后面 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] # 查看本地分支和哪个远程分支对应 git branch -vv 标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 详细编辑提交内容 $ git tag [tag] -a # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 或者 $ git push origin --delete [tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] # 拉取分支上现有的tags $ git fetch --tags 查看信息 # 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 只显示提交 $ git log --oneline # 提交树 $ git log --oneline --graph # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其\u0026#34;提交说明\u0026#34;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 本地与远程的差集 :（显示远程有而本地没有的commit信息 git log local_branch..origin/remote_branch # 统计文件的改动 git diff --stat dev origin/master # 显示今天你写了多少行代码 $ git diff --shortstat \u0026#34;@{0 day ago}\u0026#34; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交和回退 $ git reflog # 就算是被硬重置了也能看到已丢失的记录 远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 所有远程仓库 $ git fetch -a # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force $ git push [remote] -f # 推送所有分支到远程仓库 $ git push [remote] --all 撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 将在工作空间但是不在暂存区的文件撤销更改 git restore \u0026lt;file\u0026gt; # 将暂存区的文件从暂存区撤出，但不会更改文件 git restore --staged \u0026lt;file\u0026gt; # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 --hard危险操作 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 未push时, 撤销上次commit $ git reset --soft HEAD^ --soft # 不删除工作空间的改动代码，撤销commit，撤销的commit会退到暂存区 --hard # 清空工作区和暂存区，撤销commit --mixed # 不删除工作空间的改动代码，撤销commit, 重置暂存区, 撤销的commit和暂存区会退到工作区 # 改注释 # 另外一点，如果commit注释写错了，先要改一下注释 $ git commit --amend # 这时候会进入vim编辑器，修改完成你要的注释后保存即可。 # 或者上次提交少了一点，改错了一点， 把少的add, 把错的改正， 再git commit --amend -m # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 例如：假设当前提交是c2, 上一次提交是c1, 执行 git revert HEAD，会新增一个提交c2\u0026#39;， 提交的状态和c1一样， 用处就是可以把这次变化推到远程分支上，其他开发者也能看到 # 而git reset是local的，退了就退了，其他人看不到， 还有想退到上次，要多加^, revert用 代码暂存 # 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别 $ git stash save \u0026#34;save message\u0026#34; # 查看stash了哪些存储 $ git stash list # 显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1} $ git stash show # 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show stash@{$num} -p ，比如第二个：git stash show stash@{1} -p $ git stash show -p # 应用某个存储,但不会把存储从存储列表中删除, 默认使用第一个存储,即stash@{0} $ git stash apply # 命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除, 默认为第一个stash,即stash@{0} $ git stash pop # 丢弃stash@{$num}存储，从列表中删除这个存储 $ git stash drop stash@{$num} # 删除所有缓存的stash $ git stash clear # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop 其他 # 生成一个可供发布的压缩包 $ git archive 分支管理 https://www.ruanyifeng.com/blog/2012/07/git.html\ngit branch 进入编辑状态 命令行输入git branch，发现进入编辑状态，都要:wq，非常不方便，这样配置\ngit config --global core.pager ''\n测试能否联通: $ ssh -T git@192.168.10.40 Git中全局忽略.DS_Store文件 $ git config --global core.excludesfile ~/.gitignore $ echo .DS_Store \u0026gt;\u0026gt; ~/.gitignore git tag # 问题场景： # 同事A在本地创建tagA并push同步到了远程-\u0026gt;同事B在本地拉取了远程tagA(git fetch)-\u0026gt;同事A工作需要将远程标签tagA删除-\u0026gt;同事B用git fetch同步远端信息，git tag后发现本地仍然记录有tagA # 分析：对于远程repository中已经删除了的tag，即使使用git fetch --prune，甚至\u0026#34;git fetch --tags\u0026#34;确保下载所有tags，也不会让其在本地也将其删除的。而且，似乎git目前也没有提供一个直接的命令和参数选项可以删除本地的在远程已经不存在的tag（我目前是没找到有关这类tag问题的git命令~~，有知道的同学可以告知我下，互相进步）。 # 解决方法： $ git tag -l | xargs git tag -d #删除所有本地分支 $ git fetch origin --prune #从远程拉取所有信息 $ git branch --contains Tag_V1.0.0 # 看看本地哪个分支包含这个tag/commit #查询远程tags的命令如下： $ git ls-remote --tags origin # tag常用git命令： $ git tag #列出所有tag $ git tag -l v1.* #列出符合条件的tag（筛选作用） $ git tag [tag名] #创建轻量tag（无-m标注信息） $ git tag -a [tag名] #创建含注解的tag $ git push origin --tags #推送所有本地tag到远程 $ git push origin [本地tag名] #推送指定本地tag到远程 $ git tag -d [本地tag名] #删除本地指定tag $ git push origin :refs/tags/[远程tag名] #删除远程指定tag $ git fetch origin [远程tag名] #拉取远程指定tag $ git show [tag名] #显示指定tag详细信息 rebase 变基 $ git rebase -i HEAD~4 # 弹出一个vim, 可以让你修改4次提交的前后顺序或者删除, 会把修改后的复制一份添加到修改的起始节点, 原来的就丢了 , 后面的4是表示距离HEAD最近的4次 ## 如果这里不用 HEAD~4, 而是用id, 那么就得用倒数第5次提交后生成的id, 因为是倒数第5次提交后的那个节点开始操作的 # pick：保留该commit（缩写:p） # reword：保留该commit，但我需要修改该commit的注释（缩写:r） # edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e） # squash：将该commit和前一个commit合并（缩写:s） # fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f） # exec：执行shell命令（缩写:x） # drop：我要丢弃该commit（缩写:d） # 比如有四次提交 pick xxxxxx 倒数第四次提交的注释 pick xxxxxx 倒数第三次提交的注释 pick xxxxxx 倒数第二次提交的注释 pick xxxxxx 最后提交的注释 # 现在四次提交要合并成一次 , 并且改注释 r xxxxxx 倒数第四次提交的注释 f xxxxxx 倒数第三次提交的注释 f xxxxxx 倒数第二次提交的注释 f xxxxxx 最后提交的注释 # ctrl + c 退出, Y, 回车 , 进入编辑注释界面 # 编辑要保存的注释 # 在bigFix上找bug加了一堆调试代码, 提交了多次, 现在找到了, 解决了, 想合并到主分支上, 但不想合并那些加了调试代码的提交, 只想合并解决问题的那次提交 $ git rebase -i # 先变基 $ git cherry-pick bugfix https://www.cnblogs.com/code-xu/p/14262963.html\nhttps://www.cnblogs.com/xueweihan/p/5743327.html\n删除远程分支上的所有commit # 创建孤立分支，并切换到该分支： $ git checkout --orphan latest_branch # 2. 暂存所有文件： $ git add -A # 3. 提交所有更改： $ git commit -am \u0026#34;First Commit\u0026#34; # 4. 删除主分支 master： $ git branch -D master # 5. 重命名当前分支为 master： git branch -m master # 6. 强制推送本地分支： $ git push -f origin master 把本地分支换成原程分支 $ git fetch -a $ git reset --hard origin/master # master指想换的分支 $ git pull 非快速合并   使用非快速合并的优势\n 分支树更明显\n版本回退时更明确\n 设置使用git merge --no-ff 合并分支\n# even create extra merge commit when fast forward merge would be possible $ git config --global merge.ff false # 因为git pull 默认为 git fetch + git merge # 全局设置了no-ff, 会导致git pull 多一次merge local记录 # 设置 pull 时用ff, 或者用rebase, 可以避免这种情况 # 推荐使用 git pull --rebase # Disallows non ff merges on pull. Overrides merge.ff when pulling # git config --global pull.ff only   git pull \u0026ndash;rebase   git pull \u0026ndash;rebase的优势\n 拉取远程分支到本地, 合并时把本地的提交放到最后, 保持提交曲线为直线, 易于理解\n   默认git pull 和 git pull \u0026ndash;rebase的区别\n 远程分支origin上其他开发人员提交了 D, 自己本地分支提交了 E  git pull : 把\u0026quot;origin\u0026quot;分支上的修改pull下来与本地提交合并（merge）成版本M，但这样会形成图中的菱形，让人很困惑。  git pull \u0026ndash;rebase : 创建一个新的提交R，R的文件内容和上面M的一样，但将E提交废除，当它不存在（图中用虚线表示）。rebase的好处是避免了菱形的产生，保持提交曲线为直线，让大家易于理解。\n    全局设置避免每次带参\n  # set up pull to rebase instead of merge $ git config --global pull.rebase true  解决冲突和git pull不同  # 冲突 # 1. 手动解决冲突 # 2.  $ git add # 3.  $ git rebase --continue # 终止rebase, 分支会回到rebase开始前的状态 $ git rebase --abort Submodule 子模块 新增 git submodule add git://github.com/josephj/javascript-platform-yui.git static/platform 查看\ngit status # 发现只列出 submodule 目录而不是里面所有的文件 commit\ngit add . git commmit -m \u0026#39;git add submodule\u0026#39; init\n# init后.git/config会记录submodule git submodule init 更新 git pull 时不会自动更新模块, 必须手动更新\n# 进入目录 cd static/platform git pull origin master # 和第一次添加一样, 并不会在status里显示模块里面的文件更新 # submodule的版本控制在于submodule git 的 commit id, 所以要提交这些更新记录 git add static/platform git commit -m \u0026#39;submodule update\u0026#39; 更新所有的模块\n# 必须先有.gitmodules文件 # 更新.gitmodules的人使用git submodule init git submodule update 修改模块  先进子模块里面正常修改提交 再到项目里提交  删除模块  先删除目录  git rm --cached [欲移除的目錄] rm -rf [欲移除的目錄]  修改 .gitmodules\n  修改 .git/config\n  commit\n  安全起见再sync下\n  git submodule sync windows和linux下的换行符 推荐统一用LF\n  方案1： 增加 .gitattribute 文件\n在 repo 目录下新建 .gitattribute 文件，内容为：\n* text eol=lf   方案2： 修改 Git 配置\n# win系统 git config --global core.autocrlf false git config --global core.eol lf # mac linu unix 系统 git config --global core.autocrlf input // 提交时把 CRLF 转换成 LF，签出时不转换 git config --global core.safecrlf true // 不允许混用 如果只需要修改当前仓库，去掉 --global。\n  MacOs批量转换crlf为lf   安装\nbrew install dos2unix   find ./ -name \u0026#34;*\u0026#34; | xargs dos2unix   ","date":"2022-01-04T14:15:26+08:00","permalink":"/p/git-common-command/","title":"Git常用命令"},{"content":"markdown 笔记 锚点\n标题 # 一级标题\u0026lt;h1\u0026gt; ## 二级标题\u0026lt;h2\u0026gt; ### 三级标题\u0026lt;h3\u0026gt; #### 四级标题\u0026lt;h4\u0026gt; ##### 五级标题\u0026lt;h5\u0026gt; 强调 *斜体的文字* _斜体的文字_ 斜体的文字\n**粗体的文字** __粗体的文字__ 粗体的文字\n***加粗斜体的文字*** 加粗斜体的文字\n~~删除线的文字~~ 删除线的文字\n这些~~符号~~*可以***组合** 这些符号可以组合\n超链接 Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。\n行内式 [链接文字](链接地址 \u0026#34;title可选\u0026#34;) 例:\n[GitHub](http://github.com) [GitHub](http://github.com \u0026#34;这就是个提示\u0026#34;) 例: GitHub GitHub\n（ps:段首加空格，shift+space切换到全角，直接加空格）\n参考式  参考式多用在学术论文上，或者在文章中多处使用相同链接。\n [链接文字][链接标记] [链接标记]:链接地址 \u0026#34;链接标题\u0026#34; `任意地方添加` 如果链接文字可以当链接标记:\n[链接文字][] [链接文字]: 链接文字 链接文字\n例:[Github][1]、[Google][2]、[知乎][]是我经常去的网站。 [1]: http://github.com [2]: http://www.google.com [知乎]: https://www.zhihu.com/ 例:Github、Google、知乎是我经常去的网站。\n自动短链接 \u0026lt;http://example.com/\u0026gt; \u0026lt;address@example.com\u0026gt; http://example.com/\naddress@example.com\n锚点 网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。\n\u0026lt;span id=\u0026#34;jump\u0026gt;锚点\u0026lt;/span\u0026gt; [文字](#jump) 例：跳转到开头 (ps: windows要按住ctrl, mac要按主cmd)\n列表 无序列表 * 无序列表一 * 无序列表二 * 无序列表三 - 无序列表一 - 无序列表二 - 无序列表三 + 无序列表一 + 无序列表二 + 无序列表三  无序列表一 无序列表二 无序列表三   无序列表一 无序列表二 无序列表三   无序列表一 无序列表二 无序列表三  有序列表 1. 有序列表一 2. 有序列表二 3. 有序列表三  (ps:注意符号后面有空格)\n  有序列表项 一\n  有序列表项 二\n  有序列表项 三\n  定义型列表 定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法冒号紧跟一个缩进(Tab)  Markdown 轻量级文本标记语言，可以转换成html，pdf等格式  列表缩进 * 轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 * 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。   轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。\n那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。\n软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！\n  那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。\n寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。\n但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！\n悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。\n  包含引用的列表 * 阅读的方法 \u0026gt; 静下心 \u0026gt; 打开书本    阅读的方法\n 静下心 打开书本\n   引用 \u0026gt; 引用的内容  引用的内容\n 引用的多层嵌套 \u0026gt; 第一层 \u0026gt; \u0026gt; 第二层 \u0026gt; \u0026gt; \u0026gt; 第三层  第一层\n 第二层\n 第三层\n   引用块内的其他语法 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等。\n let a = null 加粗\n 插入图片 行内式 ![alt](url) ps: 为了让图片左对齐, 在前面加一个空格即可  图片alt \n参考式 ![alt][标记] [标记]: 图片地址 \u0026#34;Title\u0026#34;  猫 \n目录 直接在文章头部加[TOP] ps:部分编辑器支持,部分不支持 脚注 添加脚注的地方[^1] [^1]: 脚注的内容 ps: 脚注和脚注之间应该空一行 添加脚注的地方1\n表格 |学号|姓名|分数| |-|-|-| |小明|男|75| |小红|女|79| |小陆|男|92|    学号 姓名 分数     小明 男 75   小红 女 79   小陆 男 92    省略写法 学号|姓名|分数 -|-|- 小明|男|75 小红|女|79 小陆|男|92    学号 姓名 分数     小明 男 75   小红 女 79   小陆 男 92    对齐 学号|姓名|分数 :-|:-:|-: 小明|男|75 小红|女|79 小陆|男|92 ps: 第一列左对齐, 第二列居中, 第三列右对齐    学号 姓名 分数     小明 男 75   小红 女 79   小陆 男 92    分隔线 *** --- ___    代码 行内式 `代码` test\n代码块 ​```js let a = 1 ​``` let a = 1 可展开的代码块 \u0026lt;details\u0026gt; \u0026lt;summary\u0026gt;CLICK ME\u0026lt;/summary\u0026gt; \u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;let a = 0 return a \u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;/details\u0026gt;  CLICK ME let a = 0 return a   HTML 在代码区块里面，\u0026amp;、\u0026lt;和\u0026gt;会自动转成HTML实体 HTML原始码，只需要复制贴上，剩下的Markdown都会帮你处理 \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;2\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;3\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;4\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;5\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;6\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt;   1 2 3   4 5 6     脚注的内容 \u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-12-30T00:00:00Z","permalink":"/p/markdown-note/","title":"Markdown笔记"},{"content":" 登录Nextlify，用github账号授权登陆即可。 选择 “New site from Git”——“Github”——选择自己hugo博客源码对应的仓库——自动部署。 注：可以选择私人仓库，并且public可以配置.gitignore不用上传。  遇到的报错：\nProduction: master@HEAD Failed failed during stage 'building site': Build script returned non-zero exit code: 255 遇事不觉谷人希，stackoverflow上找到类似答案，需要修改Netlify控制台的环境变量与实际Hugo版本一致。  官方说明\n技术问题千万别用百度，垃圾csdn。\n“setting”——“Build\u0026amp;deploy”——“Environment”——\u0026quot;Environment variables\u0026quot;——“Edit variables”，左边填“HUGO_VERSION”，右边填“v0.65.3”。\n注：版本号以实际hugo version获取为准。\n同时搜索到另一种解决方法，但未实际验证。  在网站根目录下新建netlify.toml的文件。\n[build] publish = \u0026#34;public\u0026#34; command = \u0026#34;hugo --gc --minify\u0026#34; [context.production.environment] HUGO_VERSION = \u0026#34;0.65.3\u0026#34; HUGO_ENV = \u0026#34;production\u0026#34; HUGO_ENABLEGITINFO = \u0026#34;true\u0026#34; [context.split1] command = \u0026#34;hugo --gc --minify --enableGitInfo\u0026#34; [context.split1.environment] HUGO_VERSION = \u0026#34;0.65.3\u0026#34; HUGO_ENV = \u0026#34;production\u0026#34; [context.deploy-preview] command = \u0026#34;hugo --gc --minify --buildFuture -b $DEPLOY_PRIME_URL\u0026#34; [context.deploy-preview.environment] HUGO_VERSION = \u0026#34;0.65.3\u0026#34; [context.branch-deploy] command = \u0026#34;hugo --gc --minify -b $DEPLOY_PRIME_URL\u0026#34; [context.branch-deploy.environment] HUGO_VERSION = \u0026#34;0.65.3\u0026#34; [context.next.environment] HUGO_ENABLEGITINFO = \u0026#34;true\u0026#34; ","date":"2020-02-28T00:00:00Z","permalink":"/p/netlify-and-hugo/","title":"使用netlify部署hugo注意事项"},{"content":"​ 在切换Hexo到Hugo的过程中，由于有很多误操作造成提交记录很难看，需要清空历史提交记录。\n  切换到新的分支。\ngit checkout --orphan latest_branch   缓存所有的文件（除了.gitignore中声明排除的）\ngit add -A   提交跟踪过的文件。\ngit commit -m \u0026#34;提交记录\u0026#34;   删除master分支。\ngit branch -D master   重命名当前分支为master。\ngit branch -m master   提交到远程master分支。\ngit push -f origin master   ","date":"2020-02-27T00:00:00Z","permalink":"/p/delete-all-gitcommit/","title":"git删除所有历史提交记录"},{"content":"参考方法:https://blog.csdn.net/weixin_41741743/article/details/82814954\n教训:学习编程不要用中文版\n一: windows→preferences→java→editor→content assist→advanced→勾选Java Prolosals→选中Template Proposals→保存退出\n注意:发现重新打开会有丢失这一配置现象.\n二: windows→preferences→java→editor→content assist→Auto activation delay(ms)设置200→Auto activation triggers for Java设置.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxya(注意前面的点不要丢)→保存退出\n三: windows →preferences→General→keys→Content asist→word completion快捷键删掉→Binding项改为“ALT+/”→When项选择成Editing Text→保存退出\n","date":"2019-12-21T00:00:00Z","permalink":"/p/eclipse-error/","title":"解决eclipse未自动补全问题的记录"},{"content":" 通过git int把目录变成Git可以管理的仓库。 所有的版本管理系统，其实只能跟踪文本文件的改动，比如txt、网页、程序代码等。 强烈建议使用标准的utf-8编码，不要用windows自带的记事本编辑任何文本，要用utf-8 without BOM。  一.创建版本库 1.1.创建空目录 mkdir 目录名 //新建目录 cd 目录名 pwd //显示当前目录路径 1.2.把目录变成Git可以管理的仓库 git init 会看到该目录下生成.git的目录\n1.3.把文件添加到仓库 git add \u0026lt;file\u0026gt; 可反复多次使用，添加多个文件\n1.4.把文件提交到仓库 git commit -m \u0026#34;xxx\u0026#34; -m \u0026ldquo;xxx\u0026quot;本次提交的说明，commit可以一次提交很多文件。\n二.时空穿梭   查看仓库当前状态\ngit status\n  查看具体修改内容\ngit diff 要查看的文件\n  diff就是difference的缩写。\n2.1.版本回退 2.1.1.命令查看提交日志 git log 退出按 Q 觉得输出信息太多，可以加参数\ngit log --pretty=oneline 一大串xxxxxxxxxxx是commin id（版本号）。HEAD是当前版本；HEAD^是上一版本；HEAD^^是上上版本；上100版本，用HEAD~100。 查看文件版本\ncat 文件 2.1.2.版本回退 用git reset\ngit reset --hard HEAD^ 回退到上一版本。同时会修改工作区的文件。\n2.1.3取消版本回退 如果命令窗口还没关闭，往回拉，找到commit_id版本号：\ngit reset --hard 版本号的前几位 如果命令窗口已经关了，查看命令历史，找到版本号：\ngit reflog （ps：git base 按两下tab会有命令提示）\n2.2.工作区、暂存区和master分支  \n \n一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：\n$ git status # On branch master nothing to commit (working directory clean)  git diff HEAD -- 文件名 //注意：在 -- 前面和后面都有空格。 可以查看工作区和版本库最新版的区别。\n2.3.撤销修改 2.3.1.工作区 git checkout -- file 暂存区已提交，就回到暂存区状态；未提交暂存区，就回到版本库的状态。 其中--很重要。\n2.3.2.暂存区 把暂存区撤销，放回工作区\ngit reset HEAD file 然后把工作区撤销\ngit checkout -- file 2.4.删除文件 删除本地文件\nrm file 删除版本库文件，并且提交\ngit rm file git commit -m \u0026#34;xxx\u0026#34; 如果是删错了，恢复到版本库\ngit checkout -- file git checkout实际上是用版本库替换工作区，无论是修改还是删除，都可以还原。\n三.远程仓库   创建ssh key\nssh-keygen -t rsa -C \u0026ldquo;youremail@example.com\u0026rdquo;\n  测试ssh\nssh -T git@github.com 3.1.添加远程库   关联本地仓库\ngit remote add origin git@github.com:example/example\n  如果报错\nfatal：remote origin already exists 只要先删除，再添加：\n$ git remote rm origin 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。\n  把本地库的所有内容推送到远程库上：\ngit push -u origin master\n  把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n从现在起，只要本地作了提交，就可以通过命令：\ngit push origin master 3.2.从远程库克隆\ngit clone git@github.com:example/example 四.分支管理 4.1.创建与合并分支 通过指针的变化\n \n  首先，我们创建dev分支，然后切换到dev分支：\ngit checkout -b dev\n   \ngit checkout命令加上-b参数表示创建并切换，相当于以下两条命令：\n$ git branch dev $ git checkout dev Switched to branch \u0026#39;dev\u0026#39;   用git branch命令查看当前分支,当前分支前面会标一个*号：\n$ git branch\n*dev\nmaster\n  分支的提交\n   \n  切换回主分支\ngit checkout master\n   \n  把dev分支的工作成果合并到master分支上：\ngit merge dev\n  git merge命令是合并指定分支到当前分支。\n \n  删除dev分支\ngit branch -d dev\n  因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。\n  可以用git push origin :dev 删除远程分支dev。\n4.2.解决冲突 当两条分支对同一个文件的同一个文本块进行了不同的修改，并试图合并时，Git不能自动合并的，称之为冲突(conflict)。解决冲突需要人工处理。\ndev分支和master分支有不同提交\n \n这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突。\n git status也可以告诉我们冲突的文件,\u0026laquo;\u0026laquo;\u0026laquo;\u0026lt;，=======，\u0026raquo;\u0026raquo;\u0026raquo;\u0026gt;标记出不同分支的内容。  对于简单的合并，手工编辑，然后去掉这些标记，最后像往常的提交一样先add再commit即可。\n \n 用git log \u0026ndash;graph命令可以看到分支合并图   注意分支和分支并不是完完全全的平行.在切换分支前, 一定要在做出改动的分支将改动提交, 否则可能会将改动带到切换到的分支, 产生误会. 只要提前提交了, 改动就不会带过去。 其实多个分支是共用暂存区的，也就是说如果在分支1上仅add而不commit，实际暂存区中已经记录该次修改。哪怕后续切换到分支2上再进行commit也是有效的操作，只不过已经不是自己想要的处理。 合并如果没有冲突出现也就是自动合并成功, 则在当前分支中不需要add/commit提交合并后的内容, 因为实际上当前分支在合并成功后就指向了最近的commit(由做出改动的分支提交)。  4.3.分支管理策略 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。\n如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\ngit merge --no-ff -m \u0026#34;描述\u0026#34; dev 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。\n查看分支历史\ngit log --graph --pretty=oneline --abbrev-commit  \n \n在实际开发中，应该按照几个基本原则进行分支管理：\nmaster分支应该是非常稳定的，仅用来发布新版本，平时不在上面干活；\ndev分支是不稳定的，发布版本时，把dev分支合并到master上，发布1.0版本。\n每个人都有自己的分支，时不时地往dev上合并。\n \n4.4.Bug分支 当前工作到一般还不能提交，但是又要修复bug添加bugfix分支，可以用stash存储工作状态。\n$ git stash 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。\n修完bug,回到原来分支，用git status list查看存储状态。用git stash apply恢复，git stash drop清空。或者用git stash pop一步完成。\ngit stash pop 4.5.Feature分支 添加实验性功能时，不希望乱七八遭的代码把主分支打乱，最好添加feature分支，在上面开发，完成后合并、删除。\n4.6.多人协作 当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。\n要查看远程库的信息，用git remote：\ngit remote 或者，用git remote -v显示更详细的信息：\ngit remote -v 并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？\n  master分支是主分支，因此要时刻与远程同步；\n  dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；\n  bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；\n  feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。\n  小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：\n$ git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程。\n小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送，失败。\n小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。\ngit pull git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，先设置dev和origin/dev的链接，再pull：\n$ git branch --set-upstream dev origin/dev $ git pull 多人协作的工作模式通常是这样：\n  首先，可以试图用git push origin branch-name推送自己的修改；\n  如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；\n  如果合并有冲突，则解决冲突，并在本地提交；\n  没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！\n  如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch \u0026ndash;set-upstream branch-name origin/branch-name。\n  这就是多人协作的工作模式，一旦熟悉了，就非常简单。\n五.标签管理 tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。\n5.1.创建标签 切换到需要打标签的分支上：\ngit branch git checkout master git tag v1.0 给master分支打上了v1.0的标签。\n查看所有标签：\ngit tag 以前的commit忘记打标签了，需要找到commit id：\ngit log --pretty=oneline --abbrev-commit 找到id比如是xxx\n打上标签\ngit tag v0.9 xxx 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show 查看标签信息：\ngit show v0.9 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字\ngit tag -a v0.1 -m \u0026#34;version 0.1 released\u0026#34; xxxid 用命令git show 可以看到说明文字：\ngit show v0.1 还可以通过-s用私钥签名一个标签：\ngit tag -s v0.2 -m \u0026#34;signed version 0.2 released\u0026#34; xxxid 签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错。\n5.2.操作标签 如果标签打错了要删除：\ngit tag -d v0.1 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。\n如果要推送某个标签到远程，使用命令git push origin ：\ngit push origin v1.0 或者，一次性推送全部尚未推送到远程的本地标签：\ngit push origin --tags 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：\ngit tag -d v0.9 然后，从远程删除。\ngit push origin :refs/tags/v0.9 要看看是否真的从远程库删除了标签，可以登陆GitHub查看。\n","date":"2017-11-13T00:00:00Z","permalink":"/p/git-note/","title":"git笔记"},{"content":"用Github Page 搭免费博客 一.搭建hexo博客\n1.安装Node.js\n下载地址：传送门\n下载的文件是.msi后缀的，win10-x64-ltsb2016直接双击安装可能会出现2502、2503错误，在安装文件所在目录下，Shit+右键，在此处打开命令窗口，输入msiexec /i 文件名.msi ，就能成功安装。（如果还是无效，用管理员权限cmd）\n可以通过node -v命令来测试NodeJS是否安装成功。\n2.安装Git\n下载地址：传送门\n下载相应版本完成安装，可以通过git -version命令来测试git是否安装成功。\n3.注册Github账号\n准备好fq工具，注册时的usename用户名和邮箱很重要，因为默认的博客地址是https://usename.github.io/这种形式的，邮箱则关系到安全和通知。\n3.1添加SSH Key\nSSH Key是一个认证，让github识别绑定这台机器，允许这台机器提交。执行如下命令：\ncd ~/. ssh ~这个符号，表示在用户目录下 执行代码如果提示：No such file or directory 说明你是第一次使用git。\n新建新的SSH Key\n在Git Bash执行代码：\nssh-keygen -t rsa -C \u0026quot;你的邮箱@gmail.com\u0026quot; 注意：此处的-C的是大写的。\n然后系统会要求你输入密码（密码在后面每次提交都需要输入，嫌麻烦可以直接两次回车不设置）：\nEnter passphrase (empty for no passphrase):\u0026lt;输入加密串\u0026gt; Enter same passphrase again:\u0026lt;再次输入加密串\u0026gt; 在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。\n 输入密码的时候没有 * 字样的，你直接输入就可以了。 邮箱输错/密码忘记，  \u0026mdash;待完善 2020-02-22尝试迁移hexo到hugo\n","date":"2017-11-13T00:00:00Z","permalink":"/p/github-page-blog/","title":"用Github Page 搭免费博客"},{"content":"1.背景图 用户设置：\n// 背景图 \u0026quot;background.useDefault\u0026quot;: false, \u0026quot;background.customImages\u0026quot;: [ \u0026quot;file:///D:/Pictures/头图/1.png\u0026quot;, \u0026quot;file:///D:/Pictures/头图/2.png\u0026quot;, \u0026quot;file:///D:/Pictures/头图/3.png\u0026quot;]  图片整体大小用ps调整就可以了。\n","date":"2017-11-08T00:00:00Z","permalink":"/p/vscode-setting/","title":"vscode使用笔记"}]