<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>git on Jqtmviyu's Blog</title><link>/categories/git/</link><description>Recent content in git on Jqtmviyu's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 04 Jan 2022 14:15:26 +0800</lastBuildDate><atom:link href="/categories/git/index.xml" rel="self" type="application/rss+xml"/><item><title>Git常用命令</title><link>/p/git-common-command/</link><pubDate>Tue, 04 Jan 2022 14:15:26 +0800</pubDate><guid>/p/git-common-command/</guid><description>&lt;h1 id="git">Git&lt;/h1>
&lt;h2 id="git-常用命令">Git 常用命令&lt;/h2>
&lt;h3 id="仓库">仓库&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 在当前目录新建一个Git代码库&lt;/span>
$ git init
&lt;span class="c1"># 新建一个目录，将其初始化为Git代码库&lt;/span>
$ git init &lt;span class="o">[&lt;/span>project-name&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 下载一个项目和它的整个代码历史&lt;/span>
$ git clone &lt;span class="o">[&lt;/span>url&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 下载指定分支&lt;/span>
$ git clone -b &lt;span class="o">[&lt;/span>branchName&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>url&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置">配置&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 显示当前的Git配置&lt;/span>
$ git config --list
&lt;span class="c1"># 编辑Git配置文件&lt;/span>
$ git config -e &lt;span class="o">[&lt;/span>--global&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 设置提交代码时的用户信息&lt;/span>
$ git config &lt;span class="o">[&lt;/span>--global&lt;span class="o">]&lt;/span> user.name &lt;span class="s2">&amp;#34;[name]&amp;#34;&lt;/span>
$ git config &lt;span class="o">[&lt;/span>--global&lt;span class="o">]&lt;/span> user.email &lt;span class="s2">&amp;#34;[email address]&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="增加删除文件">增加/删除文件&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 添加指定文件到暂存区&lt;/span>
$ git add &lt;span class="o">[&lt;/span>file1&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>file2&lt;span class="o">]&lt;/span> ...
&lt;span class="c1"># 添加指定目录到暂存区，包括子目录&lt;/span>
$ git add &lt;span class="o">[&lt;/span>dir&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 添加当前目录的所有文件到暂存区&lt;/span>
$ git add .
&lt;span class="c1"># 添加每个变化前，都会要求确认&lt;/span>
&lt;span class="c1"># 对于同一个文件的多处变化，可以实现分次提交&lt;/span>
$ git add -p
&lt;span class="c1"># 删除工作区文件，并且将这次删除放入暂存区&lt;/span>
$ git rm &lt;span class="o">[&lt;/span>file1&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>file2&lt;span class="o">]&lt;/span> ...
&lt;span class="c1"># 停止追踪指定文件，但该文件会保留在工作区&lt;/span>
$ git rm --cached &lt;span class="o">[&lt;/span>file&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 改名文件，并且将这个改名放入暂存区&lt;/span>
$ git mv &lt;span class="o">[&lt;/span>file-original&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>file-renamed&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="代码提交">代码提交&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 提交暂存区到仓库区&lt;/span>
$ git commit -m &lt;span class="o">[&lt;/span>message&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 提交暂存区的指定文件到仓库区&lt;/span>
$ git commit &lt;span class="o">[&lt;/span>file1&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>file2&lt;span class="o">]&lt;/span> ... -m &lt;span class="o">[&lt;/span>message&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 提交工作区自上次commit之后的变化，直接到仓库区&lt;/span>
$ git commit -a
&lt;span class="c1"># 提交时显示所有diff信息&lt;/span>
$ git commit -v
&lt;span class="c1"># 使用一次新的commit，替代上一次提交&lt;/span>
&lt;span class="c1"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息&lt;/span>
$ git commit --amend
&lt;span class="c1"># 或者&lt;/span>
$ git commit --amend -m &lt;span class="o">[&lt;/span>message&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 重做上一次commit，并包括指定文件的新变化&lt;/span>
$ git commit --amend &lt;span class="o">[&lt;/span>file1&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>file2&lt;span class="o">]&lt;/span> ...
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="分支">分支&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 列出所有本地分支&lt;/span>
$ git branch
&lt;span class="c1"># 列出所有远程分支&lt;/span>
$ git branch -r
&lt;span class="c1"># 列出所有本地分支和远程分支&lt;/span>
$ git branch -a
&lt;span class="c1"># 新建一个分支，但依然停留在当前分支&lt;/span>
$ git branch &lt;span class="o">[&lt;/span>branch-name&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 新建一个分支，并切换到该分支&lt;/span>
$ git checkout -b &lt;span class="o">[&lt;/span>branch&lt;span class="o">]&lt;/span>
$ git checkout -b dev origin/dev &lt;span class="c1"># 新建分支dev并切换到该分支, 链接到远程dev分支&lt;/span>
&lt;span class="c1">#　让分支指向另一个提交&lt;/span>
git branch main HEAD~3 &lt;span class="c1"># 让main分支指向head的前第3个提交&lt;/span>
&lt;span class="c1"># 或者&lt;/span>
git branch -f main HEAD~3 &lt;span class="c1"># -f表示强制&lt;/span>
&lt;span class="c1"># 新建一个分支，指向指定commit&lt;/span>
$ git branch &lt;span class="o">[&lt;/span>branch&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 新建一个分支，与指定的远程分支建立追踪关系&lt;/span>
$ git branch --track &lt;span class="o">[&lt;/span>branch&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>remote-branch&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 切换到指定分支，并更新工作区&lt;/span>
$ git checkout &lt;span class="o">[&lt;/span>branch-name&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 切换到上一个分支&lt;/span>
$ git checkout -
&lt;span class="c1"># 建立追踪关系，在现有分支与指定的远程分支之间&lt;/span>
$ git branch --set-upstream &lt;span class="o">[&lt;/span>branch&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>remote-branch&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 或者&lt;/span>
$ git branch -u origin/master local-branch &lt;span class="c1"># 简写&lt;/span>
&lt;span class="c1"># 这样 local-branch 就会跟踪 origin/master 了。如果当前就在 local-branch 分支上, 还可以省略 local-branch&lt;/span>
$ git branch -u origin/master
&lt;span class="c1"># 合并指定分支到当前分支&lt;/span>
$ git merge &lt;span class="o">[&lt;/span>branch&lt;span class="o">]&lt;/span> &lt;span class="c1"># (不推荐)&lt;/span>
$ git merge --no-ff 要合并的分支 &lt;span class="o">(&lt;/span>推荐, 不使用快速合并, 提交历史更加清晰, 不容易出错&lt;span class="o">)&lt;/span>
&lt;span class="c1"># git 分支合并到主分支时，去掉分支的冗余提交。即，将分支的多次提交一次性合并到主分支上。&lt;/span>
$ git checkout master &lt;span class="c1"># 切换到主分支&lt;/span>
$ git merge --squash dev &lt;span class="c1"># 一次性合并分支的多次提交&lt;/span>
$ git commit -m &lt;span class="s1">&amp;#39;xxx版&amp;#39;&lt;/span> &lt;span class="c1"># 将刚‘合并的提交’提交到主分支master&lt;/span>
&lt;span class="c1"># 选择一个commit，拷贝分支合并进当前分支, 比如把dev的c2和c4拷贝为c2&amp;#39;, c4&amp;#39;, 加到到main分支后面&lt;/span>
$ git cherry-pick &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 删除分支&lt;/span>
$ git branch -d &lt;span class="o">[&lt;/span>branch-name&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 删除远程分支&lt;/span>
$ git push origin --delete &lt;span class="o">[&lt;/span>branch-name&lt;span class="o">]&lt;/span>
$ git branch -dr &lt;span class="o">[&lt;/span>remote/branch&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 查看本地分支和哪个远程分支对应&lt;/span>
git branch -vv
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="标签">标签&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 列出所有tag&lt;/span>
$ git tag
&lt;span class="c1"># 新建一个tag在当前commit&lt;/span>
$ git tag &lt;span class="o">[&lt;/span>tag&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 详细编辑提交内容&lt;/span>
$ git tag &lt;span class="o">[&lt;/span>tag&lt;span class="o">]&lt;/span> -a
&lt;span class="c1"># 新建一个tag在指定commit&lt;/span>
$ git tag &lt;span class="o">[&lt;/span>tag&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 删除本地tag&lt;/span>
$ git tag -d &lt;span class="o">[&lt;/span>tag&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 删除远程tag&lt;/span>
$ git push origin :refs/tags/&lt;span class="o">[&lt;/span>tagName&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 或者&lt;/span>
$ git push origin --delete &lt;span class="o">[&lt;/span>tagName&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 查看tag信息&lt;/span>
$ git show &lt;span class="o">[&lt;/span>tag&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 提交指定tag&lt;/span>
$ git push &lt;span class="o">[&lt;/span>remote&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>tag&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 提交所有tag&lt;/span>
$ git push &lt;span class="o">[&lt;/span>remote&lt;span class="o">]&lt;/span> --tags
&lt;span class="c1"># 新建一个分支，指向某个tag&lt;/span>
$ git checkout -b &lt;span class="o">[&lt;/span>branch&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>tag&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 拉取分支上现有的tags&lt;/span>
$ git fetch --tags
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="查看信息">查看信息&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 显示有变更的文件&lt;/span>
$ git status
&lt;span class="c1"># 显示当前分支的版本历史&lt;/span>
$ git log
&lt;span class="c1"># 只显示提交&lt;/span>
$ git log --oneline
&lt;span class="c1"># 提交树&lt;/span>
$ git log --oneline --graph
&lt;span class="c1"># 显示commit历史，以及每次commit发生变更的文件&lt;/span>
$ git log --stat
&lt;span class="c1"># 搜索提交历史，根据关键词&lt;/span>
$ git log -S &lt;span class="o">[&lt;/span>keyword&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 显示某个commit之后的所有变动，每个commit占据一行&lt;/span>
$ git log &lt;span class="o">[&lt;/span>tag&lt;span class="o">]&lt;/span> HEAD --pretty&lt;span class="o">=&lt;/span>format:%s
&lt;span class="c1"># 显示某个commit之后的所有变动，其&amp;#34;提交说明&amp;#34;必须符合搜索条件&lt;/span>
$ git log &lt;span class="o">[&lt;/span>tag&lt;span class="o">]&lt;/span> HEAD --grep feature
&lt;span class="c1"># 显示某个文件的版本历史，包括文件改名&lt;/span>
$ git log --follow &lt;span class="o">[&lt;/span>file&lt;span class="o">]&lt;/span>
$ git whatchanged &lt;span class="o">[&lt;/span>file&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 显示指定文件相关的每一次diff&lt;/span>
$ git log -p &lt;span class="o">[&lt;/span>file&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 显示过去5次提交&lt;/span>
$ git log -5 --pretty --oneline
&lt;span class="c1"># 显示所有提交过的用户，按提交次数排序&lt;/span>
$ git shortlog -sn
&lt;span class="c1"># 显示指定文件是什么人在什么时间修改过&lt;/span>
$ git blame &lt;span class="o">[&lt;/span>file&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 显示暂存区和工作区的差异&lt;/span>
$ git diff
&lt;span class="c1"># 显示暂存区和上一个commit的差异&lt;/span>
$ git diff --cached &lt;span class="o">[&lt;/span>file&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 显示工作区与当前分支最新commit之间的差异&lt;/span>
$ git diff HEAD
&lt;span class="c1"># 显示两次提交之间的差异&lt;/span>
$ git diff &lt;span class="o">[&lt;/span>first-branch&lt;span class="o">]&lt;/span>...&lt;span class="o">[&lt;/span>second-branch&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 本地与远程的差集 :（显示远程有而本地没有的commit信息&lt;/span>
git log local_branch..origin/remote_branch
&lt;span class="c1"># 统计文件的改动&lt;/span>
git diff --stat dev origin/master
&lt;span class="c1"># 显示今天你写了多少行代码&lt;/span>
$ git diff --shortstat &lt;span class="s2">&amp;#34;@{0 day ago}&amp;#34;&lt;/span>
&lt;span class="c1"># 显示某次提交的元数据和内容变化&lt;/span>
$ git show &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 显示某次提交发生变化的文件&lt;/span>
$ git show --name-only &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 显示某次提交时，某个文件的内容&lt;/span>
$ git show &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span>:&lt;span class="o">[&lt;/span>filename&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 显示当前分支的最近几次提交和回退&lt;/span>
$ git reflog
&lt;span class="c1"># 就算是被硬重置了也能看到已丢失的记录&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="远程同步">远程同步&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 下载远程仓库的所有变动&lt;/span>
$ git fetch &lt;span class="o">[&lt;/span>remote&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 所有远程仓库&lt;/span>
$ git fetch -a
&lt;span class="c1"># 显示所有远程仓库&lt;/span>
$ git remote -v
&lt;span class="c1"># 显示某个远程仓库的信息&lt;/span>
$ git remote show &lt;span class="o">[&lt;/span>remote&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 增加一个新的远程仓库，并命名&lt;/span>
$ git remote add &lt;span class="o">[&lt;/span>shortname&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>url&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 取回远程仓库的变化，并与本地分支合并&lt;/span>
$ git pull &lt;span class="o">[&lt;/span>remote&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>branch&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 上传本地指定分支到远程仓库&lt;/span>
$ git push &lt;span class="o">[&lt;/span>remote&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>branch&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 强行推送当前分支到远程仓库，即使有冲突&lt;/span>
$ git push &lt;span class="o">[&lt;/span>remote&lt;span class="o">]&lt;/span> --force
$ git push &lt;span class="o">[&lt;/span>remote&lt;span class="o">]&lt;/span> -f
&lt;span class="c1"># 推送所有分支到远程仓库&lt;/span>
$ git push &lt;span class="o">[&lt;/span>remote&lt;span class="o">]&lt;/span> --all
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="撤销">撤销&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 恢复暂存区的指定文件到工作区&lt;/span>
$ git checkout &lt;span class="o">[&lt;/span>file&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 恢复某个commit的指定文件到暂存区和工作区&lt;/span>
$ git checkout &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>file&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 恢复暂存区的所有文件到工作区&lt;/span>
$ git checkout .
&lt;span class="c1"># 将在工作空间但是不在暂存区的文件撤销更改&lt;/span>
git restore &amp;lt;file&amp;gt;
&lt;span class="c1"># 将暂存区的文件从暂存区撤出，但不会更改文件&lt;/span>
git restore --staged &amp;lt;file&amp;gt;
&lt;span class="c1"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变&lt;/span>
$ git reset &lt;span class="o">[&lt;/span>file&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 重置暂存区与工作区，与上一次commit保持一致 --hard危险操作&lt;/span>
$ git reset --hard
&lt;span class="c1"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变&lt;/span>
$ git reset &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致&lt;/span>
$ git reset --hard &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 未push时, 撤销上次commit&lt;/span>
$ git reset --soft HEAD^
--soft
&lt;span class="c1"># 不删除工作空间的改动代码，撤销commit，撤销的commit会退到暂存区&lt;/span>
--hard
&lt;span class="c1"># 清空工作区和暂存区，撤销commit&lt;/span>
--mixed
&lt;span class="c1"># 不删除工作空间的改动代码，撤销commit, 重置暂存区, 撤销的commit和暂存区会退到工作区&lt;/span>
&lt;span class="c1"># 改注释&lt;/span>
&lt;span class="c1"># 另外一点，如果commit注释写错了，先要改一下注释&lt;/span>
$ git commit --amend
&lt;span class="c1"># 这时候会进入vim编辑器，修改完成你要的注释后保存即可。&lt;/span>
&lt;span class="c1"># 或者上次提交少了一点，改错了一点， 把少的add, 把错的改正， 再git commit --amend -m&lt;/span>
&lt;span class="c1"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变&lt;/span>
$ git reset --keep &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 新建一个commit，用来撤销指定commit&lt;/span>
&lt;span class="c1"># 后者的所有变化都将被前者抵消，并且应用到当前分支&lt;/span>
$ git revert &lt;span class="o">[&lt;/span>commit&lt;span class="o">]&lt;/span>
&lt;span class="c1"># 例如：假设当前提交是c2, 上一次提交是c1, 执行 git revert HEAD，会新增一个提交c2&amp;#39;， 提交的状态和c1一样， 用处就是可以把这次变化推到远程分支上，其他开发者也能看到&lt;/span>
&lt;span class="c1"># 而git reset是local的，退了就退了，其他人看不到， 还有想退到上次，要多加^, revert用&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="代码暂存">代码暂存&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别&lt;/span>
$ git stash save &lt;span class="s2">&amp;#34;save message&amp;#34;&lt;/span>
&lt;span class="c1"># 查看stash了哪些存储&lt;/span>
$ git stash list
&lt;span class="c1"># 显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1}&lt;/span>
$ git stash show
&lt;span class="c1"># 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show stash@{$num} -p ，比如第二个：git stash show stash@{1} -p&lt;/span>
$ git stash show -p
&lt;span class="c1"># 应用某个存储,但不会把存储从存储列表中删除, 默认使用第一个存储,即stash@{0}&lt;/span>
$ git stash apply
&lt;span class="c1"># 命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除, 默认为第一个stash,即stash@{0}&lt;/span>
$ git stash pop
&lt;span class="c1"># 丢弃stash@{$num}存储，从列表中删除这个存储&lt;/span>
$ git stash drop stash@&lt;span class="o">{&lt;/span>&lt;span class="nv">$num&lt;/span>&lt;span class="o">}&lt;/span>
&lt;span class="c1"># 删除所有缓存的stash&lt;/span>
$ git stash clear
&lt;span class="c1"># 暂时将未提交的变化移除，稍后再移入&lt;/span>
$ git stash
$ git stash pop
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="其他">其他&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 生成一个可供发布的压缩包&lt;/span>
$ git archive
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="分支管理">分支管理&lt;/h3>
&lt;p>&lt;a href="https://www.ruanyifeng.com/blog/2012/07/git.html">https://www.ruanyifeng.com/blog/2012/07/git.html&lt;/a>&lt;/p>
&lt;h3 id="git-branch-进入编辑状态httpswwwcnblogscomwzndkjp10711393html">&lt;a class="link" href="https://www.cnblogs.com/wzndkj/p/10711393.html" target="_blank" rel="noopener"
>git branch 进入编辑状态&lt;/a>&lt;/h3>
&lt;p>命令行输入git branch，发现进入编辑状态，都要:wq，非常不方便，这样配置&lt;/p>
&lt;p>&lt;code>git config --global core.pager ''&lt;/code>&lt;/p>
&lt;h3 id="测试能否联通">测试能否联通:&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ ssh -T git@192.168.10.40
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="git中全局忽略ds_store文件">Git中全局忽略.DS_Store文件&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git config --global core.excludesfile ~/.gitignore
$ &lt;span class="nb">echo&lt;/span> .DS_Store &amp;gt;&amp;gt; ~/.gitignore
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="git-tag">git tag&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 问题场景：&lt;/span>
&lt;span class="c1"># 同事A在本地创建tagA并push同步到了远程-&amp;gt;同事B在本地拉取了远程tagA(git fetch)-&amp;gt;同事A工作需要将远程标签tagA删除-&amp;gt;同事B用git fetch同步远端信息，git tag后发现本地仍然记录有tagA&lt;/span>
&lt;span class="c1"># 分析：对于远程repository中已经删除了的tag，即使使用git fetch --prune，甚至&amp;#34;git fetch --tags&amp;#34;确保下载所有tags，也不会让其在本地也将其删除的。而且，似乎git目前也没有提供一个直接的命令和参数选项可以删除本地的在远程已经不存在的tag（我目前是没找到有关这类tag问题的git命令~~，有知道的同学可以告知我下，互相进步）。&lt;/span>
&lt;span class="c1"># 解决方法：&lt;/span>
$ git tag -l &lt;span class="p">|&lt;/span> xargs git tag -d &lt;span class="c1">#删除所有本地分支&lt;/span>
$ git fetch origin --prune &lt;span class="c1">#从远程拉取所有信息&lt;/span>
$ git branch --contains Tag_V1.0.0 &lt;span class="c1"># 看看本地哪个分支包含这个tag/commit&lt;/span>
&lt;span class="c1">#查询远程tags的命令如下：&lt;/span>
$ git ls-remote --tags origin
&lt;span class="c1"># tag常用git命令：&lt;/span>
$ git tag &lt;span class="c1">#列出所有tag&lt;/span>
$ git tag -l v1.* &lt;span class="c1">#列出符合条件的tag（筛选作用）&lt;/span>
$ git tag &lt;span class="o">[&lt;/span>tag名&lt;span class="o">]&lt;/span> &lt;span class="c1">#创建轻量tag（无-m标注信息）&lt;/span>
$ git tag -a &lt;span class="o">[&lt;/span>tag名&lt;span class="o">]&lt;/span> &lt;span class="c1">#创建含注解的tag&lt;/span>
$ git push origin --tags &lt;span class="c1">#推送所有本地tag到远程&lt;/span>
$ git push origin &lt;span class="o">[&lt;/span>本地tag名&lt;span class="o">]&lt;/span> &lt;span class="c1">#推送指定本地tag到远程&lt;/span>
$ git tag -d &lt;span class="o">[&lt;/span>本地tag名&lt;span class="o">]&lt;/span> &lt;span class="c1">#删除本地指定tag&lt;/span>
$ git push origin :refs/tags/&lt;span class="o">[&lt;/span>远程tag名&lt;span class="o">]&lt;/span> &lt;span class="c1">#删除远程指定tag&lt;/span>
$ git fetch origin &lt;span class="o">[&lt;/span>远程tag名&lt;span class="o">]&lt;/span> &lt;span class="c1">#拉取远程指定tag&lt;/span>
$ git show &lt;span class="o">[&lt;/span>tag名&lt;span class="o">]&lt;/span> &lt;span class="c1">#显示指定tag详细信息&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="rebase-变基">rebase 变基&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git rebase -i HEAD~4
&lt;span class="c1"># 弹出一个vim, 可以让你修改4次提交的前后顺序或者删除, 会把修改后的复制一份添加到修改的起始节点, 原来的就丢了 , 后面的4是表示距离HEAD最近的4次&lt;/span>
&lt;span class="c1">## 如果这里不用 HEAD~4, 而是用id, 那么就得用倒数第5次提交后生成的id, 因为是倒数第5次提交后的那个节点开始操作的&lt;/span>
&lt;span class="c1"># pick：保留该commit（缩写:p）&lt;/span>
&lt;span class="c1"># reword：保留该commit，但我需要修改该commit的注释（缩写:r）&lt;/span>
&lt;span class="c1"># edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）&lt;/span>
&lt;span class="c1"># squash：将该commit和前一个commit合并（缩写:s）&lt;/span>
&lt;span class="c1"># fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）&lt;/span>
&lt;span class="c1"># exec：执行shell命令（缩写:x）&lt;/span>
&lt;span class="c1"># drop：我要丢弃该commit（缩写:d）&lt;/span>
&lt;span class="c1"># 比如有四次提交&lt;/span>
pick xxxxxx 倒数第四次提交的注释
pick xxxxxx 倒数第三次提交的注释
pick xxxxxx 倒数第二次提交的注释
pick xxxxxx 最后提交的注释
&lt;span class="c1"># 现在四次提交要合并成一次 , 并且改注释&lt;/span>
r xxxxxx 倒数第四次提交的注释
f xxxxxx 倒数第三次提交的注释
f xxxxxx 倒数第二次提交的注释
f xxxxxx 最后提交的注释
&lt;span class="c1"># ctrl + c 退出, Y, 回车 , 进入编辑注释界面&lt;/span>
&lt;span class="c1"># 编辑要保存的注释&lt;/span>
&lt;span class="c1"># 在bigFix上找bug加了一堆调试代码, 提交了多次, 现在找到了, 解决了, 想合并到主分支上, 但不想合并那些加了调试代码的提交, 只想合并解决问题的那次提交&lt;/span>
$ git rebase -i &lt;span class="c1"># 先变基&lt;/span>
$ git cherry-pick bugfix
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://www.cnblogs.com/code-xu/p/14262963.html">https://www.cnblogs.com/code-xu/p/14262963.html&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.cnblogs.com/xueweihan/p/5743327.html">https://www.cnblogs.com/xueweihan/p/5743327.html&lt;/a>&lt;/p>
&lt;h3 id="删除远程分支上的所有commit">删除远程分支上的所有commit&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 创建孤立分支，并切换到该分支：&lt;/span>
$ git checkout --orphan latest_branch
&lt;span class="c1"># 2. 暂存所有文件：&lt;/span>
$ git add -A
&lt;span class="c1"># 3. 提交所有更改：&lt;/span>
$ git commit -am &lt;span class="s2">&amp;#34;First Commit&amp;#34;&lt;/span>
&lt;span class="c1"># 4. 删除主分支 master：&lt;/span>
$ git branch -D master
&lt;span class="c1"># 5. 重命名当前分支为 master：&lt;/span>
git branch -m master
&lt;span class="c1"># 6. 强制推送本地分支：&lt;/span>
$ git push -f origin master
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="把本地分支换成原程分支">把本地分支换成原程分支&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git fetch -a
$ git reset --hard origin/master &lt;span class="c1"># master指想换的分支&lt;/span>
$ git pull
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="非快速合并">非快速合并&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>使用非快速合并的优势&lt;/p>
&lt;blockquote>
&lt;p>分支树更明显&lt;/p>
&lt;p>版本回退时更明确&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://cdn.staticaly.com/gh/jqtmviyu/blogimagebed/images/images/分支树.jpg" style="zoom:50%;" />&lt;/p>
&lt;p>设置使用&lt;code>git merge --no-ff &lt;/code>合并分支&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># even create extra merge commit when fast forward merge would be possible&lt;/span>
$ git config --global merge.ff &lt;span class="nb">false&lt;/span>
&lt;span class="c1"># 因为git pull 默认为 git fetch + git merge&lt;/span>
&lt;span class="c1"># 全局设置了no-ff, 会导致git pull 多一次merge local记录&lt;/span>
&lt;span class="c1"># 设置 pull 时用ff, 或者用rebase, 可以避免这种情况&lt;/span>
&lt;span class="c1"># 推荐使用 git pull --rebase&lt;/span>
&lt;span class="c1"># Disallows non ff merges on pull. Overrides merge.ff when pulling&lt;/span>
&lt;span class="c1"># git config --global pull.ff only&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="git-pull---rebase">git pull &amp;ndash;rebase&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>git pull &amp;ndash;rebase的优势&lt;/p>
&lt;blockquote>
&lt;p>拉取远程分支到本地, 合并时把本地的提交放到最后, 保持提交曲线为直线, 易于理解&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>默认git pull 和 git pull &amp;ndash;rebase的区别&lt;/p>
&lt;ol>
&lt;li>远程分支origin上其他开发人员提交了 &lt;code>D&lt;/code>, 自己本地分支提交了 &lt;code>E&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://cdn.staticaly.com/gh/jqtmviyu/blogimagebed/images/images/20220104141037.png" alt="image.png" style="zoom:50%;" />&lt;/p>
&lt;ol start="2">
&lt;li>&lt;strong>git pull&lt;/strong> : 把&amp;quot;origin&amp;quot;分支上的修改pull下来与本地提交合并（merge）成版本M，但这样会形成图中的菱形，让人很困惑。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://cdn.staticaly.com/gh/jqtmviyu/blogimagebed/images/images/20220104141055.png" alt="image.png" style="zoom:50%;" />&lt;/p>
&lt;ol start="3">
&lt;li>&lt;strong>git pull &amp;ndash;rebase&lt;/strong> : 创建一个新的提交R，R的文件内容和上面M的一样，但将E提交废除，当它不存在（图中用虚线表示）。rebase的好处是避免了菱形的产生，保持提交曲线为直线，让大家易于理解。&lt;br>
&lt;img src="https://cdn.staticaly.com/gh/jqtmviyu/blogimagebed/images/images/20220104141104.png" alt="image.png" style="zoom:50%;" />&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>全局设置避免每次带参&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># set up pull to rebase instead of merge&lt;/span>
$ git config --global pull.rebase &lt;span class="nb">true&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>解决冲突和git pull不同&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 冲突&lt;/span>
&lt;span class="c1"># 1. 手动解决冲突&lt;/span>
&lt;span class="c1"># 2. &lt;/span>
$ git add
&lt;span class="c1"># 3. &lt;/span>
$ git rebase --continue
&lt;span class="c1"># 终止rebase, 分支会回到rebase开始前的状态&lt;/span>
$ git rebase --abort
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="submodule-子模块">Submodule 子模块&lt;/h2>
&lt;h3 id="新增">新增&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git submodule add git://github.com/josephj/javascript-platform-yui.git static/platform
&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git status
&lt;span class="c1"># 发现只列出 submodule 目录而不是里面所有的文件&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>commit&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git add .
git commmit -m &lt;span class="s1">&amp;#39;git add submodule&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>init&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># init后.git/config会记录submodule&lt;/span>
git submodule init
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="更新">更新&lt;/h3>
&lt;p>git pull 时不会自动更新模块, 必须手动更新&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 进入目录&lt;/span>
&lt;span class="nb">cd&lt;/span> static/platform
git pull origin master
&lt;span class="c1"># 和第一次添加一样, 并不会在status里显示模块里面的文件更新&lt;/span>
&lt;span class="c1"># submodule的版本控制在于submodule git 的 commit id, 所以要提交这些更新记录&lt;/span>
git add static/platform
git commit -m &lt;span class="s1">&amp;#39;submodule update&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>更新所有的模块&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 必须先有.gitmodules文件&lt;/span>
&lt;span class="c1"># 更新.gitmodules的人使用git submodule init&lt;/span>
git submodule update
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="修改模块">修改模块&lt;/h3>
&lt;ol>
&lt;li>先进子模块里面正常修改提交&lt;/li>
&lt;li>再到项目里提交&lt;/li>
&lt;/ol>
&lt;h3 id="删除模块">删除模块&lt;/h3>
&lt;ol>
&lt;li>先删除目录&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git rm --cached &lt;span class="o">[&lt;/span>欲移除的目錄&lt;span class="o">]&lt;/span>
rm -rf &lt;span class="o">[&lt;/span>欲移除的目錄&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>
&lt;p>修改 .gitmodules&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修改 .git/config&lt;/p>
&lt;/li>
&lt;li>
&lt;p>commit&lt;/p>
&lt;/li>
&lt;li>
&lt;p>安全起见再sync下&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git submodule sync
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="windows和linux下的换行符">windows和linux下的换行符&lt;/h2>
&lt;p>推荐统一用&lt;code>LF&lt;/code>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>方案1： 增加 .gitattribute 文件&lt;/p>
&lt;p>在 repo 目录下新建 &lt;code>.gitattribute&lt;/code> 文件，内容为：&lt;/p>
&lt;pre>&lt;code>* text eol=lf
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>方案2： 修改 Git 配置&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># win系统&lt;/span>
git config --global core.autocrlf &lt;span class="nb">false&lt;/span>
git config --global core.eol lf
&lt;span class="c1"># mac linu unix 系统&lt;/span>
git config --global core.autocrlf input // 提交时把 CRLF 转换成 LF，签出时不转换
git config --global core.safecrlf &lt;span class="nb">true&lt;/span> // 不允许混用
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果只需要修改当前仓库，去掉 &lt;code>--global&lt;/code>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="macos批量转换crlf为lf">MacOs批量转换crlf为lf&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>安装&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">brew install dos2unix
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">find ./ -name &lt;span class="s2">&amp;#34;*&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> xargs dos2unix
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol></description></item><item><title>git删除所有历史提交记录</title><link>/p/delete-all-gitcommit/</link><pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate><guid>/p/delete-all-gitcommit/</guid><description>&lt;p>​ 在切换Hexo到Hugo的过程中，由于有很多误操作造成提交记录很难看，需要清空历史提交记录。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>切换到新的分支。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git checkout --orphan latest_branch
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>缓存所有的文件（除了.gitignore中声明排除的）&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git add -A
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>提交跟踪过的文件。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git commit -m &lt;span class="s2">&amp;#34;提交记录&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>删除master分支。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git branch -D master
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>重命名当前分支为master。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git branch -m master
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>提交到远程master分支。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git push -f origin master
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol></description></item><item><title>git笔记</title><link>/p/git-note/</link><pubDate>Mon, 13 Nov 2017 00:00:00 +0000</pubDate><guid>/p/git-note/</guid><description>&lt;ul>
&lt;li>通过&lt;code>git int&lt;/code>把目录变成Git可以管理的仓库。&lt;/li>
&lt;li>所有的版本管理系统，其实只能跟踪文本文件的改动，比如txt、网页、程序代码等。&lt;/li>
&lt;li>强烈建议使用标准的utf-8编码，不要用windows自带的记事本编辑任何文本，要用utf-8 without BOM。&lt;/li>
&lt;/ul>
&lt;h2 id="一创建版本库">一.创建版本库&lt;/h2>
&lt;h3 id="11创建空目录">1.1.创建空目录&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">mkdir 目录名 //新建目录
&lt;span class="nb">cd&lt;/span> 目录名
&lt;span class="nb">pwd&lt;/span> //显示当前目录路径
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="12把目录变成git可以管理的仓库">1.2.把目录变成Git可以管理的仓库&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git init
&lt;/code>&lt;/pre>&lt;/div>&lt;p>会看到该目录下生成.git的目录&lt;/p>
&lt;h3 id="13把文件添加到仓库">1.3.把文件添加到仓库&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git add &amp;lt;file&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可反复多次使用，添加多个文件&lt;/p>
&lt;h3 id="14把文件提交到仓库">1.4.把文件提交到仓库&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git commit -m &lt;span class="s2">&amp;#34;xxx&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>-m &amp;ldquo;xxx&amp;quot;本次提交的说明，commit可以一次提交很多文件。&lt;/p>
&lt;h2 id="二时空穿梭">二.时空穿梭&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>查看仓库当前状态&lt;/p>
&lt;p>git status&lt;/p>
&lt;/li>
&lt;li>
&lt;p>查看具体修改内容&lt;/p>
&lt;p>git diff 要查看的文件&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>diff就是difference的缩写。&lt;/p>
&lt;h3 id="21版本回退">2.1.版本回退&lt;/h3>
&lt;h4 id="211命令查看提交日志">2.1.1.命令查看提交日志&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git log
&lt;/code>&lt;/pre>&lt;/div>&lt;p>退出按 Q
觉得输出信息太多，可以加参数&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git log --pretty&lt;span class="o">=&lt;/span>oneline
&lt;/code>&lt;/pre>&lt;/div>&lt;p>一大串&lt;code>xxxxxxxxxxx&lt;/code>是&lt;code>commin id（版本号）&lt;/code>。&lt;code>HEAD&lt;/code>是当前版本；&lt;code>HEAD^&lt;/code>是上一版本；&lt;code>HEAD^^&lt;/code>是上上版本；上100版本，用&lt;code>HEAD~100&lt;/code>。
查看文件版本&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">cat 文件
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="212版本回退">2.1.2.版本回退&lt;/h4>
&lt;p>用&lt;code>git reset&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git reset --hard HEAD^
&lt;/code>&lt;/pre>&lt;/div>&lt;p>回退到上一版本。同时会修改工作区的文件。&lt;/p>
&lt;h4 id="213取消版本回退">2.1.3取消版本回退&lt;/h4>
&lt;p>如果命令窗口还没关闭，往回拉，找到commit_id版本号：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git reset --hard 版本号的前几位
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果命令窗口已经关了，查看命令历史，找到版本号：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git reflog
&lt;/code>&lt;/pre>&lt;/div>&lt;p>（ps：git base 按两下tab会有命令提示）&lt;/p>
&lt;h3 id="22工作区暂存区和master分支">2.2.工作区、暂存区和master分支&lt;/h3>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jqtmviyu/blogimagebed@images/images/20200229044704.jpg"
loading="lazy"
>&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jqtmviyu/blogimagebed@images/images/20200229045709.jpg"
loading="lazy"
>&lt;/p>
&lt;p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git status
&lt;span class="c1"># On branch master&lt;/span>
nothing to commit &lt;span class="o">(&lt;/span>working directory clean&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git diff HEAD -- 文件名 //注意：在 -- 前面和后面都有空格。
&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以查看工作区和版本库最新版的区别。&lt;/p>
&lt;h3 id="23撤销修改">2.3.撤销修改&lt;/h3>
&lt;h4 id="231工作区">2.3.1.工作区&lt;/h4>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git checkout -- file
&lt;/code>&lt;/pre>&lt;/div>&lt;p>暂存区已提交，就回到暂存区状态；未提交暂存区，就回到版本库的状态。
其中&lt;code>--&lt;/code>很重要。&lt;/p>
&lt;h4 id="232暂存区">2.3.2.暂存区&lt;/h4>
&lt;p>把暂存区撤销，放回工作区&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git reset HEAD file
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后把工作区撤销&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git checkout -- file
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="24删除文件">2.4.删除文件&lt;/h4>
&lt;p>删除本地文件&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">rm file
&lt;/code>&lt;/pre>&lt;/div>&lt;p>删除版本库文件，并且提交&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git rm file
git commit -m &lt;span class="s2">&amp;#34;xxx&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果是删错了，恢复到版本库&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git checkout -- file
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>git checkout&lt;/code>实际上是用版本库替换工作区，无论是修改还是删除，都可以还原。&lt;/p>
&lt;h2 id="三远程仓库">三.远程仓库&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>创建ssh key&lt;/p>
&lt;p>ssh-keygen -t rsa -C &amp;ldquo;&lt;a href="mailto:youremail@example.com">youremail@example.com&lt;/a>&amp;rdquo;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>测试ssh&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">ssh -T git@github.com
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="31添加远程库">3.1.添加远程库&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>关联本地仓库&lt;/p>
&lt;p>git remote add origin &lt;a href="mailto:git@github.com">git@github.com&lt;/a>:example/example&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>如果报错&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">fatal：remote origin already exists
&lt;/code>&lt;/pre>&lt;/div>&lt;p>只要先删除，再添加：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git remote rm origin
&lt;/code>&lt;/pre>&lt;/div>&lt;p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>把本地库的所有内容推送到远程库上：&lt;/p>
&lt;p>git push -u origin master&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。&lt;/p>
&lt;p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。&lt;/p>
&lt;p>从现在起，只要本地作了提交，就可以通过命令：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git push origin master
&lt;/code>&lt;/pre>&lt;/div>&lt;p>3.2.从远程库克隆&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git clone git@github.com:example/example
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="四分支管理">四.分支管理&lt;/h2>
&lt;h3 id="41创建与合并分支">4.1.创建与合并分支&lt;/h3>
&lt;p>通过指针的变化&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jqtmviyu/blogimagebed@images/images/20200229050738.png"
loading="lazy"
>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>首先，我们创建dev分支，然后切换到dev分支：&lt;/p>
&lt;p>git checkout -b dev&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jqtmviyu/blogimagebed@images/images/20200229050034.png"
loading="lazy"
>&lt;/p>
&lt;p>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git branch dev
$ git checkout dev
Switched to branch &lt;span class="s1">&amp;#39;dev&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>用git branch命令查看当前分支,当前分支前面会标一个*号：&lt;/p>
&lt;p>$ git branch&lt;br>
*dev&lt;br>
master&lt;/p>
&lt;/li>
&lt;li>
&lt;p>分支的提交&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jqtmviyu/blogimagebed@images/images/20200229051056.png"
loading="lazy"
>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>切换回主分支&lt;/p>
&lt;p>git checkout master&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jqtmviyu/blogimagebed@images/images/20200229051225.png"
loading="lazy"
>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>把dev分支的工作成果合并到master分支上：&lt;/p>
&lt;p>git merge dev&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>git merge命令是合并指定分支到&lt;strong>当前&lt;/strong>分支。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jqtmviyu/blogimagebed@images/images/20200229051818.png"
loading="lazy"
>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>删除dev分支&lt;/p>
&lt;p>git branch -d dev&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。&lt;/em>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>可以用git push origin :dev 删除远程分支dev。&lt;/p>
&lt;h3 id="42解决冲突">4.2.解决冲突&lt;/h3>
&lt;p>当两条分支对同一个文件的同一个文本块进行了不同的修改，并试图合并时，Git不能自动合并的，称之为冲突(conflict)。解决冲突需要人工处理。&lt;/p>
&lt;p>dev分支和master分支有不同提交&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jqtmviyu/blogimagebed@images/images/20200229051904.png"
loading="lazy"
>&lt;/p>
&lt;p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突。&lt;/p>
&lt;ul>
&lt;li>git status也可以告诉我们冲突的文件,&amp;laquo;&amp;laquo;&amp;laquo;&amp;lt;，=======，&amp;raquo;&amp;raquo;&amp;raquo;&amp;gt;标记出不同分支的内容。&lt;/li>
&lt;/ul>
&lt;p>对于简单的合并，手工编辑，然后去掉这些标记，最后像往常的提交一样先add再commit即可。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jqtmviyu/blogimagebed@images/images/20200229051944.png"
loading="lazy"
>&lt;/p>
&lt;ul>
&lt;li>用git log &amp;ndash;graph命令可以看到分支合并图&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>注意分支和分支并不是完完全全的平行.在切换分支前, 一定要在做出改动的分支将改动提交, 否则可能会将改动带到切换到的分支, 产生误会. 只要提前提交了, 改动就不会带过去。&lt;/li>
&lt;li>其实多个分支是共用暂存区的，也就是说如果在分支1上仅add而不commit，实际暂存区中已经记录该次修改。哪怕后续切换到分支2上再进行commit也是有效的操作，只不过已经不是自己想要的处理。&lt;/li>
&lt;li>合并如果没有冲突出现也就是自动合并成功, 则在当前分支中不需要add/commit提交合并后的内容, 因为实际上当前分支在合并成功后就指向了最近的commit(由做出改动的分支提交)。&lt;/li>
&lt;/ol>
&lt;h3 id="43分支管理策略">4.3.分支管理策略&lt;/h3>
&lt;p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。&lt;/p>
&lt;p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git merge --no-ff -m &lt;span class="s2">&amp;#34;描述&amp;#34;&lt;/span> dev
&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。&lt;/p>
&lt;p>查看分支历史&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git log --graph --pretty&lt;span class="o">=&lt;/span>oneline --abbrev-commit
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jqtmviyu/blogimagebed@images/images/20200229052028.png"
loading="lazy"
>&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jqtmviyu/blogimagebed@images/images/20200229052106.png"
loading="lazy"
>&lt;/p>
&lt;p>在实际开发中，应该按照几个基本原则进行分支管理：&lt;/p>
&lt;p>&lt;code>master&lt;/code>分支应该是非常稳定的，仅用来发布新版本，平时不在上面干活；&lt;/p>
&lt;p>&lt;code>dev&lt;/code>分支是不稳定的，发布版本时，把&lt;code>dev&lt;/code>分支合并到&lt;code>master&lt;/code>上，发布1.0版本。&lt;/p>
&lt;p>每个人都有自己的分支，时不时地往&lt;code>dev&lt;/code>上合并。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/jqtmviyu/blogimagebed@images/images/20200229052221.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="44bug分支">4.4.Bug分支&lt;/h3>
&lt;p>当前工作到一般还不能提交，但是又要修复bug添加bugfix分支，可以用&lt;code>stash&lt;/code>存储工作状态。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git stash
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。&lt;/p>
&lt;p>修完bug,回到原来分支，用&lt;code>git status list&lt;/code>查看存储状态。用&lt;code>git stash apply&lt;/code>恢复，&lt;code>git stash drop&lt;/code>清空。或者用&lt;code>git stash pop&lt;/code>一步完成。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git stash pop
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="45feature分支">4.5.Feature分支&lt;/h3>
&lt;p>添加实验性功能时，不希望乱七八遭的代码把主分支打乱，最好添加feature分支，在上面开发，完成后合并、删除。&lt;/p>
&lt;h3 id="46多人协作">4.6.多人协作&lt;/h3>
&lt;p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。&lt;/p>
&lt;p>要查看远程库的信息，用git remote：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git remote
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者，用git remote -v显示更详细的信息：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git remote -v
&lt;/code>&lt;/pre>&lt;/div>&lt;p>并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？&lt;/p>
&lt;ul>
&lt;li>
&lt;p>master分支是主分支，因此要时刻与远程同步；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git checkout -b dev origin/dev
&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程。&lt;/p>
&lt;p>小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送，失败。&lt;/p>
&lt;p>小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git pull
&lt;/code>&lt;/pre>&lt;/div>&lt;p>git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，先设置dev和origin/dev的链接，再pull：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git branch --set-upstream dev origin/dev
$ git pull
&lt;/code>&lt;/pre>&lt;/div>&lt;p>多人协作的工作模式通常是这样：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先，可以试图用git push origin branch-name推送自己的修改；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果合并有冲突，则解决冲突，并在本地提交；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch &amp;ndash;set-upstream branch-name origin/branch-name。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。&lt;/p>
&lt;h2 id="五标签管理">五.标签管理&lt;/h2>
&lt;p>tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。&lt;/p>
&lt;h3 id="51创建标签">5.1.创建标签&lt;/h3>
&lt;p>切换到需要打标签的分支上：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git branch
git checkout master
git tag v1.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>给master分支打上了v1.0的标签。&lt;/p>
&lt;p>查看所有标签：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git tag
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以前的commit忘记打标签了，需要找到commit id：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git log --pretty&lt;span class="o">=&lt;/span>oneline --abbrev-commit
&lt;/code>&lt;/pre>&lt;/div>&lt;p>找到id比如是xxx&lt;/p>
&lt;p>打上标签&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git tag v0.9 xxx
&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show &lt;tagname>查看标签信息：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git show v0.9
&lt;/code>&lt;/pre>&lt;/div>&lt;p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git tag -a v0.1 -m &lt;span class="s2">&amp;#34;version 0.1 released&amp;#34;&lt;/span> xxxid
&lt;/code>&lt;/pre>&lt;/div>&lt;p>用命令git show &lt;tagname>可以看到说明文字：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git show v0.1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>还可以通过-s用私钥签名一个标签：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git tag -s v0.2 -m &lt;span class="s2">&amp;#34;signed version 0.2 released&amp;#34;&lt;/span> xxxid
&lt;/code>&lt;/pre>&lt;/div>&lt;p>签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错。&lt;/p>
&lt;h3 id="52操作标签">5.2.操作标签&lt;/h3>
&lt;p>如果标签打错了要删除：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git tag -d v0.1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。&lt;/p>
&lt;p>如果要推送某个标签到远程，使用命令git push origin &lt;tagname>：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git push origin v1.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者，一次性推送全部尚未推送到远程的本地标签：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git push origin --tags
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git tag -d v0.9
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后，从远程删除。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git push origin :refs/tags/v0.9
&lt;/code>&lt;/pre>&lt;/div>&lt;p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。&lt;/p></description></item></channel></rss>